# Architecting Trust: 5 Patterns to Prevent Insider Threats

"Quis custodiet ipsos custodes?" — *Who watches the watchmen?*

In the world of software, developers are the watchmen. We hold the keys to the kingdom. We write the logic that moves money, approves loans, and deletes users. But with great power comes the potential for... well, "creative" adjustments to one's own benefit.

It’s not just about malicious intent. It’s about **risk**. If a single developer can modify the production database to add a zero to their bank balance without anyone noticing, your architecture has failed. "Don't do that" is not a security policy.

Here are 5 architectural patterns to ensure that your system is resilient to insider threats and internal fraud.

---

## 1. The Maker-Checker Pattern (The 4-Eyes Principle)

This is the holy grail of financial systems. The core rule is simple: **The person who initiates an action cannot be the one who approves it.**

### The Problem
A developer writes a script to "fix" a data issue. The script also happens to credit their account with $500. They run it. Profit.

### The Solution
Separate the **Maker** (Initiator) from the **Checker** (Approver).

```mermaid
sequenceDiagram
    participant Dev as Developer (Maker)
    participant System as System
    participant Lead as Team Lead (Checker)
    participant DB as Database

    Dev->>System: Submit Script (UPDATE accounts SET balance = balance + 500 WHERE id = 123)
    System->>System: Store script in "Pending" state
    System-->>Dev: Request Queued #992

    Note over System: Script does NOT run yet.

    Lead->>System: Review Pending Requests
    Lead->>System: Approve Request #992
    System->>DB: Execute Script
    System-->>Lead: Execution Complete
```

In this architecture, the developer has the permission to `Propose`, but not to `Execute`. The Team Lead has the permission to `Approve`, but not to `Propose`. Collusion is required for fraud, doubling the difficulty.

---

## 2. Principle of Least Privilege (PoLP)

You’ve heard it before, but do you practice it?

### The Problem
Your application needs to read and write to the database. So you give the application's DB user `db_owner` or `ALL PRIVILEGES`.
A developer gains access to the config credentials and now has full control over the DB structure, including `DROP TABLE`.

### The Solution
Granular permissions. The application user should only have exactly what it needs, and no more.

*   **Application User:** `SELECT`, `INSERT`, `UPDATE` (only on specific tables). No `DELETE`? Ideally, yes (see Soft Deletes). Definitely no `DROP` or `ALTER`.
*   **Developer User:** `SELECT` (Read-only access to production).

If a developer needs to modify data, they must use a tool or API that enforces business logic (and logs it), rather than raw SQL access.

---

## 3. Event Sourcing

Traditional databases store the *current state*. Event Sourcing stores the *history*.

### The Problem
If I run `UPDATE balance SET amount = 1000 WHERE user_id = 'me'`, the previous value is gone. Traces can be wiped.

### The Solution
Don't store the state. Store the **events**.

Instead of a `Balance` column, you have a `Transactions` table. The balance is simply the sum of all transactions.

| Event ID | Timestamp | Type | Amount | User |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 10:00 AM | Deposit | +100 | Alice |
| 2 | 10:05 AM | Purchase | -20 | Alice |
| 3 | 11:00 AM | Adjustment | +5000 | Alice |

If a "creative" developer tries to inject a +5000 adjustment, it appears as a distinct row. They cannot simply "edit" the total. To calculate the balance, the system replays the events. If that +5000 lacks a valid `Origin` (like a Payment Gateway ID), the replay logic can flag it as invalid.

**You cannot change the past; you can only append to the future.**

---

## 4. Immutable Audit Logs (WORM)

**WORM** stands for **Write Once, Read Many**.

### The Problem
A developer changes a record and then deletes the corresponding line in the log file to cover their tracks.

### The Solution
Ship logs immediately to a storage medium that does not support modification or deletion for a set period.

*   **AWS S3 Object Lock:** Places a "retention period" on objects. Even the root user cannot delete them until the timer expires.
*   **Blockchain-like structures:** Each log entry contains a cryptographic hash of the previous entry. Modifying an old log breaks the chain, alerting the system immediately.

```text
Log Entry N:
{
  "timestamp": "2026-01-23T12:00:00Z",
  "action": "UPDATE_USER",
  "actor": "dev_john",
  "prev_hash": "a1b2c3d4..." // Hash of Entry N-1
}
```

---

## 5. Segregation of Duties (SoD)

This is the organizational counterpart to Maker-Checker.

### The Problem
The same person writes the code, tests the code, deploys the code, and manages the database. This is common in startups ("The Full Stack Hero"), but it’s a security nightmare.

### The Solution
Split the roles.

*   **Dev:** Writes code.
*   **Ops/SRE:** Manages deployment and infrastructure.
*   **DBA:** Manages data integrity.

If a developer wants to deploy a backdoor:
1.  They write it.
2.  **Code Review:** Peer catches it.
3.  **CI/CD:** Automated tests run on a separate server.
4.  **Ops:** Deploys the artifact (the developer doesn't have SSH access to Prod).

By breaking the chain of custody, you ensure that no single individual has the complete keys to the kingdom.

---

### Conclusion

Trust is good. Architecture is better. By implementing these patterns, you protect not just the company, but the developers themselves. When the system is secure by design, no one has to look over their shoulder, wondering if they *could* break the rules. They simply *can't*.
