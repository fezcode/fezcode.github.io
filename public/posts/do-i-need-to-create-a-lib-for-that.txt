# Do I Need to Create a Lib For That?

## My Journey into Go Libraries

Creating my first Go library, [go-tournament-brackets](https://github.com/fezcode/go-tournament-brackets), has been a, _experience_...
It's a project that allowed me to dive deep into Go's capabilities for building reusable and efficient code.
The process of designing the data structures, handling edge cases like automatic bye calculations,
and then building an interactive command-line interface on top of it was both challenging and immensely satisfying.
There's a unique sense of accomplishment in seeing your code not just work, but also be easily consumable by others.

## About `go-tournament-brackets`

`go-tournament-brackets` is a versatile Go library designed for generating and managing single-elimination tournament brackets. It offers two primary components:

*   **A Robust Go Library:** This provides a set of data models and functions that can be integrated into any Go application.
It intelligently handles tournament logic, including the correct calculation of rounds, match-ups, and automatic byes for varying numbers of participants.
*   **An Interactive Command-Line Interface (CLI):** Built on top of the library, this CLI allows users to run a tournament from start to finish.
You can input participant names, visualize the bracket in ASCII art, and interactively determine match winners until a champion is crowned.

This library aims to simplify the process of setting up and managing tournaments, whether you're integrating it into a larger application or running a quick tournament from your terminal.

## Ok, but why?

The inspiration for `go-tournament-brackets` struck during a casual phone call with a friend. I was unwinding, listening to [Morcheeba's "Easier Said than Done,"](https://www.youtube.com/watch?v=27lPAUdE1ys)
when he posed a fun challenge: rank our favorite rappers. His idea was to create a bracket, share it, and play through it together. Simple enough, right?

Not quite. As he started looking for online bracket makers, we quickly hit a wall. Most platforms demanded sign-ups,
locked away certain tournament types behind paywalls, and generally overcomplicated what should have been a straightforward,
enjoyable activity. For something so simple, the hoops we had to jump through felt entirely unnecessary.
That's when the idea sparked: why not build my own? A bracket maker that was free, flexible, and didn't force you into a convoluted user experience.
And so, the seed for `go-tournament-brackets` was planted.

## How did I do that?

The journey from idea to a working library began with a deep dive into the mechanics of tournament brackets.
I found myself poring over Wikipedia articles, unraveling the intricacies of single-elimination formats, byes, and seeding.
Once I had a solid grasp of the theoretical underpinnings, I turned to my trusty collaborator, Gemini 2.5-Pro.

My first request to Gemini was simple: "Generate the necessary Go files for a tournament bracket library."
It quickly scaffolded the basic project structure, providing the initial Go files. From there, I started defining the core data structures,
translating the concepts from my research into Go structs. The `models.go` file, which you can see [here](https://raw.githubusercontent.com/fezcode/go-tournament-brackets/refs/heads/main/models.go), was born out of this phase.

```go
// Tournament is the root object that contains all data for a tournament event.
type Tournament struct {
	Name           string
	Rounds         []Round
	TournamentType TournamentType
	Options        *Options
}
```

With the foundational structs in place, Gemini and I embarked on implementing the core logic.
This was where the real challenge and fun began. Handling the "bye" mechanism – __ensuring that teams or competitors who automatically advance in the first round are correctly placed__ – proved to be particularly tricky.
It's not as straightforward as it might seem, but with Gemini's assistance, we iterated through various approaches, and it did its best to help navigate those complexities. It was a true collaborative effort, pushing both my understanding and Gemini's capabilities to deliver a robust solution.

## Publishing Your Go Module

Once you've developed your Go package, the next step is to make it available for others to use. This involves a few crucial steps to ensure your module is correctly versioned and discoverable.

1.  **Define Your Module Path in `go.mod`:**
    Your `go.mod` file must declare the correct module path, which typically corresponds to the repository where your code is hosted. For `go-tournament-brackets`, this should be `module github.com/fezcode/go-tournament-brackets`. This path is how other Go projects will import and reference your module.

2.  **Create and Push a Version Tag (Release):**
    Go modules rely on Git tags for versioning. To publish a specific version of your module, you need to:
    *   **Tag your commit:** Use `git tag vX.Y.Z` (e.g., `git tag v0.1.0`) to mark a specific commit as a release. Semantic Versioning (SemVer) is highly recommended for your tags (e.g., `v0.1.0`, `v1.0.0`).
    *   **Push the tag:** After creating the tag locally, push it to your remote repository: `git push origin vX.Y.Z`. This makes the version visible to module proxies.

3.  **Module Discovery by Go Proxies (e.g., `proxy.golang.org`):**
    Go module proxies (like `proxy.golang.org`) automatically discover new module versions when they are tagged and pushed to a public repository. While you don't strictly *need* to run a command to "publish" in the traditional sense, you can explicitly request a proxy to fetch a new version.
    *   **Requesting a specific version:** You can use `go get github.com/fezcode/go-tournament-brackets@v0.1.0` (or `go list -m github.com/fezcode/go-tournament-brackets@v0.1.0`) from *any* Go project. I used `$env:GOPROXY="proxy.golang.org"; go list -m github.com/fezcode/go-tournament-brackets`. When this command is executed, if the proxy doesn't have that version, it will fetch it from your repository.
    *   **Important Note:** The `GOPROXY=proxy.golang.org go list -m example.com/mymodule@v0.1.0` command is primarily used to *verify* that a module can be fetched from the proxy, or to *force* a proxy to fetch a new version if it hasn't discovered it yet. It's not a "publishing" command in itself, but rather a way to interact with the proxy.

4.  **Visibility on `pkg.go.dev`:**
    After your module is tagged and discoverable by Go module proxies, `pkg.go.dev` (the official Go package discovery site) will eventually index it. This process is not instantaneous and can take some time (from minutes to a few hours). You won't see your listing immediately, so patience is indeed key!